// Container
@mixin container() {
  display: block;
  margin: 0 auto;
  width: auto;
  position: relative;
  padding-left: 15px;
  padding-right: 15px;
}

//Custom grid gutter
@mixin grid-gutter($gutter) {
  .row {
    margin-left: -#{$gutter}px;
    margin-right: -#{$gutter}px;
    & > [class*=col-] {
      padding-left: #{$gutter}px;
      padding-right: #{$gutter}px;
    }
  }
}

// code snippet styling
@mixin code-snippet() {
  font-family: monospace;
}

// =============================================================================
// String Replace
// =============================================================================

@function str-replace($string, $search, $replace: "") {
  $index: str-index($string, $search);

  @if $index {
    @return str-slice($string, 1, $index - 1) + $replace + str-replace(str-slice($string, $index + str-length($search)), $search, $replace);
  }

  @return $string;
}

// =============================================================================
// Font Face
// =============================================================================

@mixin font-face($name, $path, $weight: null, $style: null, $exts: eot woff2 woff ttf svg) {
  $src: null;

  $extmods: (
    eot: "?",
    svg: "#" + str-replace($name, " ", "_")
  );

  $formats: (
    otf: "opentype",
    ttf: "truetype"
  );

  @each $ext in $exts {
    $extmod: if(map-has-key($extmods, $ext), $ext + map-get($extmods, $ext), $ext);
    $format: if(map-has-key($formats, $ext), map-get($formats, $ext), $ext);
    $src: append($src, url(quote($path + "." + $extmod)) format(quote($format)), comma);
  }

  @font-face {
    font-family: quote($name);
    font-style: $style;
    font-weight: $weight;
    src: $src;
  }
}

/// Generates the code required for the 'object-fit-images' polyfill
/// @see https://github.com/bfred-it/object-fit-images
/// @param {String} $fit - How should the image scale to its parent?
/// @param {String} $position - The offset for the image
@mixin object-fit($fit: fill, $position: null) {
  -o-object-fit: $fit;
     object-fit: $fit;

  @if $position {
	  -o-object-position: $position;
	     object-position: $position;

    font-family: 'object-fit: #{$fit}; object-position: #{$position}';
  } @else {
  	font-family: 'object-fit: #{$fit}';
  }
}

///
@mixin typography-level($for, $key) {
  $config: map-deep-get($typography, $for, $key);
  @include typography-style($key, $config, true);
}

///
@mixin typography-style($level, $config, $styles-only: false) {
  $selector: $level;

  // Determine if this style needs a base selector in addition to a class
  $no-tag: map-has-key($config, no-tag) and map-get($config, no-tag) == true;
  $no-default: not map-has-key($config, default-selector);

  // Change the `$selector` so it reflects the default if one is set
  @if not $no-default {
    $selector: unquote(map-get($config, default-selector));
  }

  // Loop through each breakpoint and set the styles
  @each $breakpoint, $size in $grid-breakpoints {
    @if map-has-key($config, $breakpoint) {
      $break-config: map-get($config, $breakpoint);

      @if map-has-key($break-config, only) and map-get($break-config, only) == true {
        @include media-breakpoint-only($breakpoint) {
          @include typography-bp($selector, $level, $no-tag, $no-default, $break-config, $styles-only);
        }
      }
      @else {
        @include media-breakpoint-up($breakpoint) {
          @include typography-bp($selector, $level, $no-tag, $no-default, $break-config, $styles-only);
        }
      }
    }
  }
}

@mixin typography-bp(
  $selector,
  $level,
  $no-tag,
  $no-default,
  $break-config,
  $styles-only: false
) {
  @if $styles-only == true {
    @include typography-styles($break-config);
  }
  @else if $no-tag and $no-default {
    .#{$level} {
      @include typography-styles($break-config);
    }
  }
  @else {
    #{$selector},
    .#{$level} {
      @include typography-styles($break-config);
    }
  }
}

///
@mixin typography-styles($config) {
  @each $key, $value in $config {
    @if $key != 'only' {
      #{$key}: #{$value};
    }
  }
}

///
@mixin iphone-x($gutter: $grid-gutter-width / 2) {
  @supports(padding: #{'max(0px)'}) {
    & {
      @include iphone-x-prop('padding-left', $gutter);
      @include iphone-x-prop('padding-right', $gutter);
    }
  }
}

@mixin iphone-x-prop($prop, $gutter) {
  #{unquote($prop)}: #{'max(#{$gutter}, var(safe-area-inset-left))'};
  #{unquote($prop)}: #{'max(#{$gutter}, env(safe-area-inset-left))'};
}

@mixin placeholder {
  &::-webkit-input-placeholder {
    @content;
  }

  &::-moz-placeholder {  /* Firefox 19+ */
    @content;
  }

  &:-ms-input-placeholder {
    @content;
  }
}

///
@mixin container-flush($pseudo: ':not(:last-child)') {
  [class*='col']#{unquote($pseudo)} > div {
    @content;
  }
}

///
@mixin aspect-ratio(
  $width: 16,
  $height: 9,
  $selector: '.content',
  $needs-position: true
) {
  position: relative;

  &:before {
    display: block;
    content: '';
    padding-top: aspect-ratio($width, $height);
    width: 100%;
  }

  @if $needs-position == true {
    > #{unquote($selector)} {
      bottom: 0;
      left: 0;
      position: absolute;
      right: 0;
      top: 0;
    }
  }
}

///
@mixin not-aem-author() {
  html:not(.aem-AuthorLayer-Edit):not(.aem-AuthorLayer-Preview) & {
    @content;
  }
}

///
@mixin pseudo-icon($name, $size: null, $direction: left, $needs-margin: true) {
  content: get-icon($name);
  font-size: $size;

  @if $needs-margin == true {
    margin-#{$direction}: rem-calc(6px);
  }
}

// Truncate text element with ellipsis
@mixin truncate() {
  display: table;
  table-layout: fixed;
  width: 100%;
  white-space: nowrap;

  > * {
    display: table-cell;
    overflow: hidden;
    text-overflow: ellipsis;
  }
}

// global spacing mixing
@mixin spacingCompile($paddingType: Y1, $spacingType: horizontal) {
  // horizontal (left / right)
  @if $spacingType == 'horizontal' {
    padding-left: map-deep-get($spacersHorizontal, 'sm', '#{$paddingType}');
    padding-right: map-deep-get($spacersHorizontal, 'sm', '#{$paddingType}');

    @include media-breakpoint-up(md) {
      padding-left: map-deep-get($spacersHorizontal, 'md', '#{$paddingType}');
      padding-right: map-deep-get($spacersHorizontal, 'md', '#{$paddingType}');
    }

    @include media-breakpoint-up(lg) {
      padding-left: map-deep-get($spacersHorizontal, 'lg', '#{$paddingType}');
      padding-right: map-deep-get($spacersHorizontal, 'lg', '#{$paddingType}');
    }
  } @else {
  // vertical (top / bottom)
    padding-top: map-deep-get($spacersVertical, 'sm', '#{$paddingType}');
    padding-bottom: map-deep-get($spacersVertical, 'sm', '#{$paddingType}');

    @include media-breakpoint-up(md) {
      padding-top: map-deep-get($spacersVertical, 'md', '#{$paddingType}');
      padding-bottom: map-deep-get($spacersVertical, 'md', '#{$paddingType}');
    }

    @include media-breakpoint-up(lg) {
      padding-top: map-deep-get($spacersVertical, 'lg', '#{$paddingType}');
      padding-bottom: map-deep-get($spacersVertical, 'lg', '#{$paddingType}');
    }
  }
}

@mixin spacingCompileSingle($paddingOne: top, $paddingType: Y1) {
  padding-#{$paddingOne}: map-deep-get($spacersVertical, 'sm', '#{$paddingType}');

  @include media-breakpoint-up(md) {
    padding-#{$paddingOne}: map-deep-get($spacersVertical, 'md', '#{$paddingType}');
  }

  @include media-breakpoint-up(lg) {
    padding-#{$paddingOne}: map-deep-get($spacersVertical, 'lg', '#{$paddingType}');
  }
}
